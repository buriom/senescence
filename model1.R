#*******************************************************************************
#In this implementation, I assumed a constant beta and  I fitted 2 parameters, 
#i.e beta and  mu, with tau fixed
#*******************************************************************************
library("minpack.lm")
#Function for the fraction of T cells with x divisions at time t; f_t
#Parameters: delta = turn-over rate (per day, h = hayflick limit, 
# n = a hill coefficient, tau = the number of naive T cells generated by the thymus
#per day as a fraction of the total number of current T cells,
# alpha = rate for the exponential decline of thymic T cell output, 
# mu = the average number of cell divisions for cells produced from the thymus, 
# delta = the average T cell turnover per day, 
# beta =  the probability of replication

#list of fixed parameters from literature
prs <- list(
  delta = 0.0015, h=50, n=1, tau=0.0017, a=1/(33.33 *365)#fixed paramaters
)

#proportion of the T cell population with x no. of divisions at time t
f <- function(x, t, beta, mu, parms=prs) with(parms, {
  d <- 1 - beta - delta
  #sum of f_0's
  sumj0 <- dpois(x, mu) + tau / d *dpois(x, mu)* sum((d*exp(a))^(0:-x))
  #  coeffs <- d^(-(1:x))
  sumj_all <-  sumj0 +  sum(sapply(1:x,function(j) 
    d^(-j)*prod(2*beta*(h^n)/(h^n+(x - (1:j))^n))*
      (choose(t,j)*dpois(x - j, mu)+tau/d*dpois(x - j, mu)*
         sum((d*exp(a))^-(0:(x - j))*choose(x - 0:(x - j), j))))
  )
  return(d^(t) * sumj_all)
})

#calculating the immunoscence predictor
getPred <- function(mdl,t, parms, fxdParms){
  t <- (t-min(t))*365
  prdctns <- sapply(1:length(t), function(i) {
    coll <- sapply(0:100, mdl, t = t[i], parms$beta,parms$mu, 
                   fxdParms)
    #normalising
    f_t <- coll/sum(coll)
    sum(f_t[50:100])}, simplify = TRUE)
}

#calculating the disparity between predictions and observed data
residFun <- function(par, mdl,  observed, t, fxdParms){
  prdctns <- getPred(mdl, t, par, fxdParms)
  resids <- log(prdctns) - log(observed)
  return(ifelse(is.nan(resids), 1e6, resids))
}

#********************************* data fitting ******************************
.args <- c("preProcessed/Breast_data.rds")

.args <- commandArgs(trailingOnly = TRUE)

#load the data and calculate the population weights in each class
FittedData <- readRDS(.args[1])
#incidenceData <- readRDS("preProcessed/StomachCancer_data.rds")


#initial values for fitting
inits <- list(beta=0.002319,mu=31.3809); a <- c(0,0); b <- c(1,100)

obs <- FittedData$y/ max(FittedData$y)
#fitting after normalising
fit <- nls.lm(par = inits, lower = a, upper = b,
                          fn = residFun, mdl = f, fxdParms = prs, observed = obs, t = FittedData$x,
                          control = nls.lm.control(nprint=0,  ftol = 1e-3))

fit <- readRDS(fitResults, paste0("fits/model2fits/",cancer,".rds")[1])

prdctns <- getPred(f, FittedData$x, fit$par, prs)

cancer <- gsub(".*preProcessed/\\s*|_data.rds*", "", .args)

#function to Calculate the AIC
logL <- function(object, REML = FALSE, ...) { 
  
  res <- object$fvec 
  
  N <- length(res) 
  
  val <-  -N * (log(2 * pi) + 1 - log(N) + log(sum(res^2)))/2 
  
  ## the formula here corresponds to estimating sigma^2. 
  
  attr(val, "df") <- 1L + length(coef(object)) 
  
  attr(val, "nobs") <- attr(val, "nall") <- N 
  
  class(val) <- "logLik" 
  
  val 
  
}

#Calculating R^2
Rsquare <- (cor(log(obs),log(prdctns)))^2

#Calculating AIC
perfom <- 2 * (length(fit$par) + 1) - 2 * logL(fit)

fitResults <- c(beta = fit$par$beta, mu = fit$par$mu, AIC = perfom, Rsqr = Rsquare)

#saveRDS(fitResults, paste0("fits/model1fits/",cancer,".rds")[1])

jpeg(paste0('figures/model1Figs/', cancer,'.jpg'))

age <- FittedData$x
logObs <- log10(obs)
preds <- log10(prdctns)
plot(age, logObs,  col = "blue",
     xlab = "Age", ylab = bquote('log'[10]*' Incidence'), type = "p",pch =17,
     main = bquote(bold(paste(.(cancer) ," with ",tau," fixed"))))
lines(age, preds, col = "red", lwd = 3)



vertSpan <- range(logObs)
least <- vertSpan[1]
space <- (vertSpan[2]-vertSpan[1])/12
#text(70, least + 5*space, paste('\nAIC = ', round(perfom,4), '\nRSS=' , round(fit$deviance,4),  pos = 4)) 
#paste("Mean =", round(MyMean, 1), "\nMedian =", round(MyMedian, 1), "\nStd.Dev =", round(MySd, 1)), pos = 4)
text(70, (least + 0), cex = 1.2, bquote(paste(beta, '=' , .(round(fit$par$beta,6)))))
text(70, (least + 1*space), cex = 1.2, bquote(paste(mu, '=' , .(round(fit$par$mu,4)))))
text(70, (least + 2*space), cex = 1.2, expression(bold('Parameters')))
text(70, (least + 3*space), cex = 1.2, bquote(paste('RSS=' , .(round(fit$deviance,6)))))
text(70, (least + 4*space), cex = 1.2, bquote(paste('R'^2*' = ', .(round(Rsquare,5)))))
text(70, (least + 5*space), cex = 1.2, bquote(paste('AIC = ', .(round(perfom,4)))))
text(70, (least + 6*space), cex = 1.2, expression(bold('Performance')))

dev.off()
#saveRDS(fit, paste0("fits/model1fits/",cancer,".rds"))
