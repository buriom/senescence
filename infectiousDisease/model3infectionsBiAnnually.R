#*******************************************************************************
#In this implementation, I consider a time varying beta, i.e B_t, and fit 3 parameters
#, i.e   mu, delta and tau
#*******************************************************************************
library("minpack.lm")

#******************************  functions **********************************
#Function for the fraction of T cells with x divisions at time t; f_t
#Parameters: delta = turn-over rate (per day, h = hayflick limit, 
# n = a hill coefficient, tau = the number of naive T cells generated by the thymus
#per day as a fraction of the total number of current T cells,
# alpha = rate for the exponential decline of thymic T cell output, 
# mu = the average number of cell divisions for cells produced from the thymus, 
# delta = the average T cell turnover per day, 
# beta =  the probability of replication

#list of fixed parameters from literature
prs <- list(
  h=50, n=1, a=1/(33.33*365)#delta = 0.001, 
)

#proportion of the T cell population with x no. of divisions at time t
f <- function(x, t, tau, mu, beta, delta, fxdParms=prs) with(fxdParms, {
  d <- 1 - beta - delta
  #sum of f_0's
  sumj0 <- dpois(x, mu) + tau / d *dpois(x, mu)* sum((d*exp(a))^(0:x))
  #  coeffs <- d^(-(1:x))
  sumj_all <- sumj0+sum(sapply(1:x,function(j) 
    d^(-j)*prod(2*beta*(h^n)/(h^n+(x-(1:j))^n))*
      (choose(t,j)*dpois(x - j, mu) + tau/d*dpois(x - j, mu)*
         sum((d*exp(a))^-(0:(x - j))* choose(x - 0:(x - j), j))))
  )
  return(d^(t) * sumj_all)
})

#*****Calculating aging whilst updating B_t at each time step (1 yr steps) *****
getPred <- function(mdl, t, parms, fxdParms){
  #diffrce <- (20+(14-length(t))*5)
  beta <- parms$delta
  #prb <- dpois(0:100,parms$mu)
  mylist1 <- list()
  for (i in 1:length(t)){
    mylist2 <- c()
    for(j in 1:length(t[[i]])){
      #calculating the propotions for all 0...100 cell divisions 
      prb <- sapply(0:100, mdl, t = t[[i]][j], parms$tau, parms$mu,
                    beta, parms$delta, fxdParms)
      #updating beta at each time step, i.e after a year
      n <- fxdParms$n
      beta <- (parms$delta-parms$tau*exp(-fxdParms$a*t[[i]][j]))/
        (1 - 2 * sum(1/(1 + (fxdParms$h/(0:100))^n) * prb))
      #calculation immunoscence predictor by normalising the propotions from above
      mylist2[j] <- sum((prb/sum(prb))[50:100])
    }
    mylist1[[i]] <- mylist2 
  }
  return(mylist1)
}

#test
#system.time(b <- getPred(f, tpts,  inits, prs))
#b

# bestPrdctns <- function(mdl, t, parms, fxdParms){
#   diffrce <- (20+(14-length(t))*5)
#   #prb <- dpois(0:100,parms$mu)
#   beta <- parms$delta
#   propnsList <- list()
#   betaList <- list()
#   for (i in 1:length(t)){
#     mylist2 <- c()
#     mylist3 <- c()
#     for(j in 1:length(t[[i]])){
#       mylist3[j] <- beta
#       #calculating the propotions for all 0...100 cell divisions 
#       prb <- sapply(0:100, mdl, t = (t[[i]][j] -   diffrce )*365, parms$tau, parms$mu,
#                     beta, parms$delta, fxdParms)
#       beta <- (parms$delta - parms$tau*exp(-fxdParms$a*(t[[i]][j]-  diffrce )*365))/
#         (1 - 2 * sum(((0:100)^fxdParms$n/((0:100)^fxdParms$n + 
#                                             fxdParms$h^fxdParms$n)) * prb))
#       mylist2[j] <- sum((prb/sum(prb))[50:100])
#     }
#     propnsList[[i]] <- mylist2 
#     betaList[[i]] <- mylist3
#   }
#   return(list(propnsList,betaList))
# }

bestPrdctns <- function(mdl, t, parms, fxdParms){
  #diffrce <- (20+(14-length(t))*5)
  #prb <- dpois(0:100,parms$mu)
  beta <- parms$delta
  propnsList <- list()
  betaList <- list()
  for (i in 1:length(t)){
    mylist2 <- c()
    mylist3 <- c()
    for(j in 1:length(t[[i]])){
      mylist3[j] <- beta
      #calculating the propotions for all 0...100 cell divisions 
      prb <- sapply(0:100, f, t = t[[i]][j], parms$tau, parms$mu,
                    beta, parms$delta, fxdParms)
      n <- fxdParms$n
      beta <- (parms$delta-parms$tau*exp(-fxdParms$a*t[[i]][j]))/
        (1 - 2 * sum(1/(1 + (fxdParms$h/(0:100))^n) * prb))
      mylist2[j] <- sum((prb/sum(prb))[50:100])
    }
    propnsList[[i]] <- mylist2 
    betaList[[i]] <- mylist3
  }
  return(list(propnsList,betaList))
}
#system.time(b2 <- bestPrdctns(f, tpts,  inits, prs))
#

#calculating the disparity between predictions and observed data
residFun <- function(par, mdl,  observed, t, fxdParms){
  unWghtdPreds <-  getPred(mdl, t, par, fxdParms)
  #prdctns <-  mapply(function(x,y) sum(x * y)/sum(y), unWghtdPreds,wghts)
  #resids <- log10(prdctns) - log10(observed)
  resids <- log(unlist(lapply(unWghtdPreds, mean))) - log(observed)
    return(ifelse(is.nan(resids), 1e6, resids))
}

#function for calculating the AIC
logL <- function(object, REML = FALSE, ...) { 
  
  res <- object$fvec 
  
  N <- length(res) 
  
  val <-  -N * (log(2 * pi) + 1 - log(N) + log(sum(res^2)))/2 
  
  ## the formula here corresponds to estimating sigma^2. 
  
  attr(val, "df") <- 1L + length(coef(object)) 
  
  attr(val, "nobs") <- attr(val, "nall") <- N 
  
  class(val) <- "logLik" 
  
  val 
  
}
#********************************* data fitting ******************************
.args <- c("infectiousDisease/COVID-19.csv","infectiousDisease/fits/model3fits/corona.rds")


.args <- commandArgs(trailingOnly = TRUE)

#Read in data and extract timepoints and weights
# incidenceData <- readRDS(.args[1])
allDiseases <- system("ls infectiousDisease/*.csv", TRUE)

for (disease in allDiseases[c(1)]){
  FittedData <- read.csv(disease[1])
  lb <- FittedData$Age.lb
  ub <- FittedData$Age.ub
  
  lb2 <- (lb-lb[1])*365+365/2
  ub2 <- (ub-lb[1])*365
  
  tpts <-  mapply(function(i,j) seq(i,j,365/2), lb2, ub2,
                  SIMPLIFY = FALSE)
  #extract weight: 4.18 and 0.04 obtained from 
  #https://www.census.gov/prod/cen2010/briefs/c2010br-03.pdf
  # wght <-  mapply(function(i,j) {things <- i:j; ifelse( 
  #  things<50, 1, 4.18-0.04*(things))},incidenceData$Age.lb, incidenceData$Age.ub,
  #  SIMPLIFY = FALSE)
  
  
  #initial values for fitting
  inits <- list(mu=34.86982, tau=0.003024786, delta = 0.001698568); a <- c(0,0.00005,0.00005); b <- c(100,1, 1)
  
  #obs <- incidenceData$`Rate per 100,000`/max(incidenceData$`Rate per 100,000`)
  obs <- FittedData$Rate.per.100.000/max(FittedData$Rate.per.100.000)
  
  #fitting after normalising
  fit <- nls.lm(par = inits, lower = a, upper = b,
                fn = residFun, mdl = f, fxdParms = prs, observed = obs,
                t = tpts,  control = nls.lm.control(nprint=1, ftol = 1e-3))
  
  # predictions using the fitted values
  # unWghtdPreds <-  bestPrdctns(f, tpts, fit$par, prs)
  # prdctns <-  mapply(function(x,y) sum(x * y)/sum(y), unWghtdPreds[[1]],wght)
  
  prdctns1 <-  bestPrdctns(f, tpts, fit$par, prs)
  prdctns <- unlist(lapply(prdctns1[[1]], mean))
  #**********************************plotting****************************************
  #cancer <- gsub(".*preProcessed/\\s*|_data.rds*", "", .args[1])
  cancer <- gsub(".*infectiousDisease/\\s*|.csv*", "", disease)
  
  #calculate AICarameters
  perfom <- 2 * (length(fit$par) + 1) - 2 * logL(fit)
  
  #remember to change this to just fit
  saveRDS(fit$par, paste0("infectiousDisease/fits/model3fits/",cancer,".rds")[1])
  
  jpeg(paste0('infectiousDisease/figures/model3Figs/', cancer,'.jpg'))
  age <- FittedData$Age.ub
  logObs <- log10(obs)
  preds <- log10(prdctns)
  
  #Calculating R^2
  Rsquare <- cor(logObs,preds); Rsquare^2
  plot(age, logObs,  col = "blue", xlab = "Age", type = "p",pch =17, cex = 2,
       ylab = bquote('log'[10]*' Mortality'), main =
         bquote(bold(paste(.(cancer)))))
  lines(age, preds,col="red", lwd=3)
  
  #anotating the graph
  vertSpan <- range(logObs)
  least <- vertSpan[1]
  space <- (vertSpan[2]-vertSpan[1])/15
  #text(70, least + 5*space, paste('\nAIC = ', round(perfom,4), '\nRSS=' , round(fit$deviance,4),  pos = 4)) 
  #paste("Mean =", round(MyMean, 1), "\nMedian =", round(MyMedian, 1), "\nStd.Dev =", round(MySd, 1)), pos = 4)
  
  text(70, (least ), cex = 1.2, bquote(paste(tau, '=' , .(round(fit$par$tau,6)))))
  text(70, (least + 1*space), cex = 1.2, bquote(paste(mu, '=' , .(round(fit$par$mu,4)))))
  text(70, (least + 2*space), cex = 1.2, bquote(paste(delta, '=' , .(round(fit$par$delta,4)))))
  text(70, (least + 3*space), cex = 1.2, expression(bold('Parameters')))
  text(70, (least + 4*space), cex = 1.2, bquote(paste('RSS=' , .(round(fit$deviance,6)))))
  text(70, (least + 5*space), cex = 1.2, bquote(paste('R'^2*' = ', .(round(Rsquare^2,5)))))
  text(70, (least + 6*space), cex = 1.2, bquote(paste('AIC = ', .(round(perfom,4)))))
  text(70, (least + 7*space), cex = 1.2, expression(bold('Performance')))
  
  dev.off()
}


